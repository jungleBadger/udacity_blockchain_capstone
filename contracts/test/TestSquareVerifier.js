// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var verifier = artifacts.require('SquareVerifier');
/* let proof = {
    "proof":
    {
        "A":["0x2e66d4d2bacce809969d637fda357db655174b202a53039e526b985d079e5c16", "0x28d611d8761a0e46f3da89f8006998332c52108ec0279b2bda332cddeb97a5e"],
        "A_p":["0x45f4ce47d3b7645cebf5af7a0275326bf32a6ae951c8a8315bf73d7cfd2d77a", "0x6e3c6bdbaaa91d9177542d99354e3a8cf8d3eff516f97842e92c8da3dd66f57"],
        "B":
            [["0x62e26b47c27e55f0abb672bf6c7ebbdcf5a5da73586a99fd0a7ef09c23b5700", "0x2d0352592fd51b417e884f79fb12f3c6fe79050185a35abac94eabd0e79cebf3"], ["0x1a89a56c5da317d0de13844b9ffbd0fc66104129426faba34622079e5231ee76", "0xefcde715674134182f6c0523a9f954deebdc52ababc3b947277635471e1bcf3"]],
        
        "B_p":["0x5ac61a7438a01c6f5dbfa8d35d54b18df1cfcc358ede472abb25e29a5b7894f", "0x212268f96837da801f26785820869e29bb6b3731425da090542cbe53e28a254b"],
        "C":["0x2df63827d643e91284a4ba2f0c129d59a1aa85333b0684311e59fe99cbe81365", "0x101fbb1f90b86c84159fa542ee2865e8275aab29a02c5c80a0c8dad2ad32948f"],
        "C_p":["0x2470ca26d2f97bed959ce102903debb8ce3816a2b40f51310bcf16ef14163b53", "0x22a2e33837204c6e5866845089e77c2f1172072344d0632736cb90d824d974c2"],
        "H":["0x10c70702ff4bed96721175f5ac1a5a2ba2140d70f3b281e46596d8b04e404e17", "0x26cbf516cb847474ab5d612d503b321731e676f15846e270083f09e32dfea0e8"],
        "K":["0x3f0d34ba2e40e75013c22f8e554af613a15fc33044023c73adfe5c6b77a04", "0x1c39c69ea9c3433f0c5d751c6f35bceb6898d5f77d6eab1f78a6b4b6f4a95cc4"]
    },
    "input":[9,1]}; */

let proof = require("../../zokrates/code/square/proof");

contract('TestSquareVerifier', accounts => {
    
    let account = accounts[0];
    // Test verification with correct proof
    // - use the contents from proof.json generated from zokrates steps
    describe('Test verification', function () {
        beforeEach(async function () { 
            try{
                this.contract = await verifier.new({from: account});
            }
            catch(e)
            {
                console.log(e);
            }
        });
        
        it('verification with correct proof', async function () { 
              
            let result = await this.contract.verifyTx.call(
                proof.proof.A, 
                proof.proof.A_p, 
                proof.proof.B, 
                proof.proof.B_p, 
                proof.proof.C, 
                proof.proof.C_p, 
                proof.proof.H, 
                proof.proof.K, 
                proof.input,
                {from: account}
            );
        
            assert.equal(result, true, 'Proof is not Verified') ;
        });

        it('verification with incorrect proof', async function () { 
            let proofC_P = ["0x45f4ce47d3b7645cebf5af7a0275326bf32a6ae951c8a8315bf73d7cfd2d77a", "0x6e3c6bdbaaa91d9177542d99354e3a8cf8d3eff516f97842e92c8da3dd66f57"];

            let result = await this.contract.verifyTx.call(
                proof.proof.A, 
                proof.proof.A_p,
                proof.proof.B, 
                proof.proof.B_p, 
                proof.proof.C, 
                proofC_P, 
                proof.proof.H, 
                proof.proof.K, 
                proof.input,
                {from: account}
            );
    
            assert.equal(result, false, "The proof is in correct. Should not verify");
        });
    });
    
}) ;

